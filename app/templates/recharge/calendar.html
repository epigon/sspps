{% extends "base.html" %}

{% block title %}
Instrument Scheduler
{% endblock %}

{% block styles %}
{{ super() }}
<!-- FullCalendar CSS -->
<link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.css" rel="stylesheet">
<style>
    #calendar {
        max-width: 100%;
        margin: 20px auto;
    }

    #error {
        color: red;
        margin-top: 10px;
    }

    .fc-toolbar-title {
        font-weight: 600;
        font-size: 2rem;
    }

    .fc-toolbar-title::after {
        content: " ";
    }

    @keyframes pulse-danger {
        0% {
            box-shadow: 0 0 0 0 rgba(220, 53, 69, .6);
        }

        70% {
            box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
        }

        100% {
            box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
        }
    }

    .pulse {
        animation: pulse-danger 1.5s infinite;
    }
</style>
{% endblock %}

{% block content %}

<div class="container">
    <div class="my-2 border border-1 p-2 rounded-3 bg-light">

        {% if request_id or admin %}
        <div class="row my-2 p-2">
            {% if request_id %}
            <div class="col">
                <h4 class="instruction-toggle" role="button">
                    <i class="icon-toggle bi bi-caret-right-fill"></i> General Instructions
                    <!-- <span class="ms-2 text-muted btn-toggle">+ Show</span> -->
                </h4>
                <ul class="instruction-list d-none">
                    <li>Please note that only Approved requests can be scheduled.</li>
                    <li>Click on a time slot to schedule an instrument</li>
                    <li>To request to edit or delete a booking, please send an email to <a
                            href="mailto:screeningcore@health.ucsd.edu">screeningcore@health.ucsd.edu</a> with
                        information
                        on requestor name, and booking details.</li>
                </ul>
            </div>
            {% endif %}

            {% if admin %}
            <div class="col">
                <h4 class="instruction-toggle" role="button">
                    <i class="icon-toggle bi bi-caret-right-fill"></i> Instructions for Admin
                    <!-- <span class="ms-2 text-muted btn-toggle">+ Show</span> -->
                </h4>
                <ul class="instruction-list d-none">
                    <li>Click on a time slot to schedule an instrument</li>
                    <li>To edit booking, drag and drop the event to a new time slot or click and edit from the opened
                        window.
                        <ul>
                            <li>If conflicts arise, the system will alert you to allow override.</li>
                        </ul>
                    </li>
                    <li>To delete a booking, click on the event and press the "Delete" button.</li>
                </ul>
            </div>
            {% endif %}

        </div>

        {% endif %}
        <div class="col my-2 p-2" id="filtersWrapper">
            <h4>Filter by Machine:</h4>
            <div id="machineFilters" class="d-flex gap-2">
                <!-- buttons go here -->
            </div>
        </div>
    </div>
</div>

<div id="calendar"></div>


<!-- Modal -->
<div class="modal fade" id="eventModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">

            <div class="modal-header">
                <h5 class="modal-title">Add Booking</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>

            <div class="modal-body">
                {% if admin and not request_id %}
                <div class="mb-2">
                    <label class="form-label fw-bold">Approved Request</label>
                    <select id="requestSelect" class="form-select">
                        <option value="">— Select Approved Request —</option>
                    </select>
                </div>
                {% endif %}
                <div class="mb-2">
                    <label class="form-label fw-bold">Event Title</label>
                    <input type="text" id="eventTitle" class="form-control mb-2" readonly>
                </div>
                <div class="mb-2">
                    <label class="form-label fw-bold">Start Time</label>
                    <input type="datetime-local" id="eventStart" class="form-control mb-2">
                </div>
                <div class="mb-2">
                    <label class="form-label fw-bold">End Time</label>
                    <input type="datetime-local" id="eventEnd" class="form-control mb-2">
                </div>

                <div id="eventError" class="text-danger fw-bold"></div>

                {% if admin %}
                <div id="overrideSection" class="d-none mt-3 border-top pt-3 alert alert-warning">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="modalOverrideToggle">
                        <label class="form-check-label fw-bold text-danger">
                            Admin Override (ignore conflicts)
                        </label>
                    </div>
                    <div class="small text-muted">
                        This will force scheduling even if the machine is already booked.
                    </div>
                </div>
                {% endif %}

            </div>

            <div class="modal-footer">
                {% if admin %}
                <button id="deleteEventBtn" class="btn btn-danger d-none">
                    Delete
                </button>
                {% endif %}

                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button id="saveEventBtn" class="btn btn-primary">Save</button>
            </div>

        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<!-- FullCalendar -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/index.global.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<script src="https://www.google.com/recaptcha/api.js?render={{ recaptcha_site_key }}"></script>


{{ super() }}

<script>
    document.addEventListener("DOMContentLoaded", function () {

        const requestID = {{ request_id| tojson
    }};
    const isAdmin = {{ admin| tojson }};
    const isPublic = {{ public| tojson }};
    const deleteBtn = document.getElementById("deleteEventBtn");
    const RECAPTCHA_SITE_KEY = "{{ recaptcha_site_key }}";

    let calendar;
    let selectedMachines = new Set();
    // let knownMachines = new Set();
    let allEvents = [];      // store ALL events once
    let machineColors = {}; // machine → color map
    let request = null;

    // -----------------------------
    // REQUEST MODE: if requestID exists
    // -----------------------------
    if (requestID) {
        fetch(`/recharge/api/instrument-request/${requestID}`)
            .then(res => res.json())
            .then(req => {
                request = req;

                // Set event title in modal
                document.getElementById("eventTitle").value = req.machine_name + " - " + req.requestor_name;

                // Hide machine filters since only one machine is relevant
                document.getElementById("filtersWrapper").style.display = "none";

                // Only this machine is selected
                selectedMachines.clear();
                selectedMachines.add(req.machine_name);
                // Initialize calendar after setting selected machine
                fetchAllData().then(() => initCalendar());

            });
    }

    // -----------------------------
    // ADMIN / PUBLIC MODE: fetch all machines
    // -----------------------------
    else {
        // Fetch machines + colors for filter
        fetch("/recharge/api/machines")
            .then(res => res.json())
            .then(machines => {
                machines.forEach(m => selectedMachines.add(m));
                buildMachineLegend(machines); // pass color from server
                fetchAllData().then(() => initCalendar());
            });
    }

    // --------------------
    // Admin override UI
    // --------------------
    const overrideSection = document.getElementById("overrideSection");
    const modalOverride = document.getElementById("modalOverrideToggle");
    const saveBtn = document.getElementById("saveEventBtn");

    modalOverride?.addEventListener("change", () => {
        saveBtn.disabled = !modalOverride.checked;
    });


    document.getElementById("eventModal")?.addEventListener("shown.bs.modal", () => {
        const errorDiv = document.getElementById("eventError");
        if (errorDiv) errorDiv.textContent = "";

        resetOverrideUI(); // already safe after our fix
        // If NEW event and title is empty, apply default
        if (!saveBtn.dataset.eventId) {
            const titleInput = document.getElementById("eventTitle");
            if (!titleInput.value) {
                titleInput.value = getDefaultEventTitle();
            }
        }

        if (!saveBtn.dataset.eventId && deleteBtn) {
            deleteBtn.classList.add("d-none");
        }

    });


    ["eventStart", "eventEnd"].forEach(id => {
        document.getElementById(id)?.addEventListener("change", () => {
            document.getElementById("eventError").textContent = "";
        });
    });

    document.querySelectorAll(".instruction-toggle").forEach(header => {
        header.addEventListener("click", () => {
            const toggleIcon = header.querySelector(".icon-toggle");
            if (toggleIcon) {
                toggleIcon.classList.toggle("bi-caret-right-fill");
                toggleIcon.classList.toggle("bi-caret-down-fill");
            }
            const list = header.nextElementSibling;
            if (!list) return;

            list.classList.toggle("d-none");
        });
    });

    function fetchAllData() {
        return fetch("/recharge/api/events")
            .then(res => res.json())
            .then(data => {
                allEvents = data.events || [];

                data.machines.forEach(m => {
                    // selectedMachines.add(m.name);
                    machineColors[m.name] = m.color;
                });

                buildMachineLegend(data.machines);
            });
    }

    function getDefaultEventTitle() {
        // Request-based scheduling
        if (request) {
            return `${request.machine_name} — ${request.requestor_name}`;
        }

        // Admin selecting approved request
        const select = document.getElementById("requestSelect");
        if (select && select.value) {
            const opt = select.selectedOptions[0];
            return `${opt.dataset.machine} — ${opt.dataset.requestor}`;
        }

        return "";
    }


    function getOverrideEls() {
        return {
            section: document.getElementById("overrideSection"),
            toggle: document.getElementById("modalOverrideToggle"),
            save: document.getElementById("saveEventBtn")
        };
    }

    function showOverrideUI() {
        if (!isAdmin) return;

        const { section, toggle, save } = getOverrideEls();
        if (!section || !toggle || !save) return;

        section.classList.remove("d-none");
        toggle.classList.add("pulse");
        save.disabled = true;
    }

    function resetOverrideUI() {
        if (!isAdmin) return;

        const { section, toggle, save } = getOverrideEls();
        if (!section || !toggle || !save) return;

        section.classList.add("d-none");
        toggle.checked = false;
        toggle.classList.remove("pulse");
        save.disabled = false;
    }


    // Minimal MD5 function for color hashing
    function md5(str) {
        // Use a simple JS hash function for consistency
        // For production, include a proper MD5 library
        return CryptoJS.MD5(str).toString();
    }

    function buildMachineLegend(machines) {
        const container = document.getElementById("machineFilters");
        machines.forEach(m => {
            if (!m.name) return;
            
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "btn me-1 mb-1";
            btn.style.backgroundColor = m.color; // use server color
            btn.style.color = "#fff";
            btn.textContent = m.name;
            btn.dataset.active = "true";

            btn.addEventListener("click", () => {
                const active = btn.dataset.active === "true";
                btn.dataset.active = (!active).toString();
                btn.style.opacity = active ? "0.5" : "1";

                active ? selectedMachines.delete(m.name) : selectedMachines.add(m.name);
                calendar.refetchEvents();
            });

            container.appendChild(btn);
        });
    }


    // function bootstrapCalendar() {
    //     if (calendar) return; // SAFETY GUARD
    //     initCalendar();
    // }


    function isValidDateRange(startStr, endStr) {
        if (!startStr || !endStr) return false;

        const start = new Date(startStr);
        const end = new Date(endStr);

        return end > start;
    }


    function enableMachineFilter(machineName) {
        selectedMachines.add(machineName);

        const buttons = document.querySelectorAll("#machineFilters button");
        buttons.forEach(btn => {
            if (btn.textContent === machineName) {
                btn.dataset.active = "true";
                btn.style.opacity = "1";
            }
        });
    }


    // --------------------
    // Admin Approved Request dropdown
    // --------------------
    if (isAdmin) {
        fetch("/recharge/api/approved-requests")
            .then(res => res.json())
            .then(requests => {
                const select = document.getElementById("requestSelect");
                if (!select) return;

                requests.forEach(r => {
                    const opt = document.createElement("option");
                    opt.value = r.id;
                    opt.dataset.machine = r.machine_name;
                    opt.dataset.requestor = r.requestor_name;
                    opt.textContent = `${r.machine_name} — ${r.requestor_name}`;
                    select.appendChild(opt);
                });

                select.addEventListener("change", function () {
                    const option = this.selectedOptions[0];
                    if (!option) return;

                    document.getElementById("eventTitle").value = option.textContent;
                    this.dataset.machine = option.dataset.machine;
                    this.dataset.requestor = option.dataset.requestor;
                });
            });
    }


    // --------------------
    // Initialize calendar
    // --------------------
    function initCalendar() {
        calendar = new FullCalendar.Calendar(document.getElementById("calendar"), {
            initialView: "timeGridWeek",


            headerToolbar: {
                left: "prev,next today",
                center: "title",
                right: "timeGridDay,timeGridWeek"
            },

            selectable: isAdmin || (request && request.status === "Approved"),
            editable: isAdmin,

            events: function (fetchInfo, success) {
                const filtered = allEvents.filter(e =>
                    selectedMachines.has(e.extendedProps.machine_name)
                );
                success(filtered);
                // const params = new URLSearchParams();

                // if (request) {
                //     // Only fetch events for the request's machine
                //     params.append("machine", request.machine_name);
                // } else {
                //     if (selectedMachines.size === 0) {
                //         success([]); // nothing selected
                //         return;
                //     }
                //     selectedMachines.forEach(m => params.append("machine", m));
                // }

                // fetchEventsAndMachines().then(events => success(events));
                // fetch(`/recharge/api/events?${params}`)
                //     .then(res => res.json())
                //     .then(events => {
                //         const machinesFromEvents = new Set(
                //             events.map(e => e.extendedProps.machine_name)
                //         );

                //         // Add any new machines to the filter UI
                //         buildMachineLegend([...machinesFromEvents]);

                //         success(events);
                //     });
            },

            datesSet: function () {
                if (isAdmin && !request) return;

                if (isPublic) {
                    const titleEl = document.querySelector(".fc-toolbar-title");
                    if (titleEl) {
                        titleEl.textContent = "Instruments Calendar";
                    }
                    return
                }

                let titleText = "Scheduler";

                // Request mode
                if (request?.machine_name) {
                    titleText = `${request.machine_name} Scheduler`;
                }
                // Single machine selected
                else if (selectedMachines.size === 1) {
                    titleText = `${[...selectedMachines][0]} Scheduler`;
                }

                const titleEl = document.querySelector(".fc-toolbar-title");
                if (titleEl) {
                    titleEl.textContent = titleText;
                }
            },

            select: function (info) {
                if (isPublic) return;

                // ✅ RESET ADMIN MODAL STATE
                resetEventModalForNew();

                document.getElementById("eventStart").value = info.startStr.slice(0, 16);
                document.getElementById("eventEnd").value = info.endStr.slice(0, 16);

                bootstrap.Modal
                    .getOrCreateInstance(document.getElementById("eventModal"))
                    .show();
            },
            eventClick: function (info) {
                if (!isAdmin) {
                    info.jsEvent.preventDefault(); // stop navigation
                    return;                        // do nothing
                }

                const e = info.event;
                const props = e.extendedProps;

                // Pull from extendedProps
                const machineName = props.machine_name;
                const requestId = props.request_id;
                const requestorName = props.requestor_name || "";

                const requestSelect = document.getElementById("requestSelect");
                if (requestSelect) {
                    requestSelect.value = requestId || "";
                }

                // Prefill modal with event info
                const titleInput = document.getElementById("eventTitle");
                titleInput.value =
                    e.title ||
                    (machineName && requestorName
                        ? `${machineName} — ${requestorName}`
                        : "");

                document.getElementById("eventStart").value = e.startStr.slice(0, 16);
                document.getElementById("eventEnd").value = e.endStr.slice(0, 16);

                // If admin, enable override section if necessary
                resetOverrideUI();

                // Store event ID on modal save button for editing
                saveBtn.dataset.eventId = e.id;

                // Show delete button for admins
                if (isAdmin && deleteBtn) {
                    deleteBtn.classList.remove("d-none");
                    deleteBtn.dataset.eventId = e.id;
                }

                bootstrap.Modal.getOrCreateInstance(document.getElementById("eventModal")).show();
            },
            eventDidMount: function (info) {
                if (!isAdmin) {
                    info.el.style.cursor = "default";
                }

                const machine = info.event.extendedProps.machine_name;

                info.el.style.backgroundColor =
                    machineColors[machine] || "#747678";

                if (!selectedMachines.has(machine)) {
                    info.el.style.display = "none";
                }
            },
            eventDrop: handleEventMove,
            eventResize: handleEventMove
        });

        calendar.render();

    }


    // function fetchEventsAndMachines() {
    //     const params = new URLSearchParams();
    //     selectedMachines.forEach(m => params.append("machine", m));

    //     return fetch(`/recharge/api/events?${params}`)
    //         .then(res => res.json())
    //         .then(data => {
    //             // Events for FullCalendar
    //             const events = data.events;
    //             // Machine-color mapping for filter buttons
    //             const machines = data.machines;

    //             // Build legend if not yet built
    //             if (!window.machineLegendBuilt) {
    //                 buildMachineLegend(machines);
    //                 window.machineLegendBuilt = true;
    //             }

    //             return events;
    //         });
    // }


    function handleEventMove(info) {

        // First attempt: no override
        attemptMove(info, false);

    }


    function attemptMove(info, override) {
        // Execute reCAPTCHA v3
        grecaptcha.ready(function () {
            grecaptcha.execute(RECAPTCHA_SITE_KEY, { action: "submit" }).then(function (token) {

                // Add token to payload
                const payload = {
                    id: info.event.id,
                    title: info.event.title,
                    start: info.event.start.toISOString(),
                    end: info.event.end.toISOString(),
                    machine_name: info.event.extendedProps?.machine_name,
                    request_id: info.event.extendedProps?.request_id || null,
                    override: override,
                    recaptcha_token: token
                };

                fetch("/recharge/api/events/update", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload)
                })
                    .then(res => res.json().then(d => ({ ok: res.ok, body: d })))
                    .then(res => {
                        // Conflict detected
                        if (!res.ok && res.body.conflict) {

                            // Non-admins can’t override
                            if (!isAdmin) {
                                alert(res.body.error);
                                info.revert();
                                return;
                            }

                            // Ask admin to confirm override
                            const confirmed = confirm(
                                "This move conflicts with an existing booking.\n\nOverride and force the move?"
                            );

                            if (confirmed) {
                                // Retry WITH override
                                attemptMove(info, true);
                            } else {
                                info.revert();
                            }
                            return;
                        }

                        // Other error
                        if (!res.ok) {
                            alert(res.body.error || "Unable to move event.");
                            info.revert();
                        }
                    })
                    .catch(() => {
                        alert("Unexpected error while moving event.");
                        info.revert();
                    });
            });
        });
    }


    function resetEventModalForNew() {
        // Clear edit state
        delete saveBtn.dataset.eventId;

        // Reset request selector
        const requestSelect = document.getElementById("requestSelect");
        if (requestSelect) {
            requestSelect.value = "";
            delete requestSelect.dataset.machine;
            delete requestSelect.dataset.requestor;
        }

        // Clear title
        const titleInput = document.getElementById("eventTitle");
        if (titleInput) {
            titleInput.value = "";
        }

        // Hide delete button
        if (deleteBtn) {
            deleteBtn.classList.add("d-none");
            deleteBtn.removeAttribute("data-event-id");
        }

        // Reset override UI
        resetOverrideUI();

        // Clear any previous errors
        const errorDiv = document.getElementById("eventError");
        if (errorDiv) errorDiv.textContent = "";
    }


    // --------------------
    // Save Event
    // --------------------
    saveBtn.addEventListener("click", function () {

        const startVal = document.getElementById("eventStart").value;
        const endVal = document.getElementById("eventEnd").value;

        if (!isValidDateRange(startVal, endVal)) {
            document.getElementById("eventError").textContent =
                "End time must be later than start time.";
            return;
        }

        // Execute reCAPTCHA v3
        grecaptcha.ready(function () {
            grecaptcha.execute(RECAPTCHA_SITE_KEY, { action: "submit" }).then(function (token) {

                const reqSelect = document.getElementById("requestSelect");
                const requestId = requestID || reqSelect?.value || null;
                const machineName = request?.machine_name || reqSelect?.selectedOptions[0]?.dataset.machine;
                const requestorName = request?.requestor_name || reqSelect?.selectedOptions[0]?.dataset.requestor;
                const override = isAdmin && modalOverride?.checked;

                if (override) {
                    const confirmed = confirm("You are overriding an existing booking.\n\nDo you want to continue?");
                    if (!confirmed) return;
                }

                const eventId = saveBtn.dataset.eventId || null; // ✅ check if editing
                const eventTitle = document.getElementById("eventTitle").value || machineName && requestorName ? `${machineName} — ${requestorName}` : ""; // ✅ check if editing

                // Add token to payload
                const payload = {
                    id: eventId,
                    title: eventTitle,
                    start: startVal,
                    end: endVal,
                    machine_name: machineName,
                    request_id: requestId,
                    override: override,
                    recaptcha_token: token  // ✅ send token to backend
                };
                console.log("Saving event with payload:", payload);
                fetch(payload.id ? "/recharge/api/events/update" : "/recharge/api/events", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload)
                })
                    .then(res => res.json())
                    .then(data => {
                        console.log("Save response data:", data);
                        if (data.error) {
                            document.getElementById("eventError").textContent = data.error;
                            if (data.conflict) showOverrideUI();
                            return;
                        }

                        if (eventId) {
                            // Update master list
                            const idx = allEvents.findIndex(e => e.id == eventId);
                            if (idx !== -1) {
                                allEvents[idx].title = data.title;
                                allEvents[idx].start = data.start;
                                allEvents[idx].end = data.end;
                            }

                            // Update visible event
                            const event = calendar.getEventById(eventId);
                            event.setProp("title", data.title);
                            event.setStart(data.start);
                            event.setEnd(data.end);

                            // existing edit
                            // const event = calendar.getEventById(eventId);
                            // event.setProp("title", data.title);
                            // event.setStart(data.start);
                            // event.setEnd(data.end);

                            // calendar.refetchEvents();
                        } else {
                            // NEW EVENT
                            const newEvent = {
                                id: data.id,
                                title: data.title,
                                start: data.start,
                                end: data.end,
                                backgroundColor: data.backgroundColor,
                                borderColor: data.borderColor,
                                extendedProps: data.extendedProps
                            };

                            // 1️⃣ Store in master list
                            allEvents.push(newEvent);

                            // 2️⃣ Enable its machine filter
                            enableMachineFilter(newEvent.extendedProps.machine_name);

                            // 3️⃣ Re-render calendar
                            calendar.refetchEvents();

                            // ✅ NEW EVENT
                            // const machine =
                            //     data.extendedProps?.machine_name ||
                            //     data.machine_name ||
                            //     machineName;

                            // enableMachineFilter(machine);

                            // // calendar.removeAllEvents();
                            // calendar.refetchEvents();

                        }

                        resetOverrideUI();
                        delete saveBtn.dataset.eventId; // clear edit state
                        bootstrap.Modal.getInstance(document.getElementById("eventModal")).hide();

                    });
            });
        });
    });

    // Delete Event
    deleteBtn?.addEventListener("click", function () {
        const eventId = this.dataset.eventId;
        if (!eventId) return;

        if (!confirm("Are you sure you want to delete this booking?")) return;

        grecaptcha.ready(function () {
            grecaptcha.execute(
                RECAPTCHA_SITE_KEY,
                { action: "submit" }
            ).then(function (token) {

                fetch("/recharge/api/events/delete", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        id: eventId,
                        recaptcha_token: token
                    })
                })
                    .then(res => res.json())
                    .then(data => {
                        if (data.error) {
                            alert(data.error);
                            return;
                        }

                        // Remove from calendar
                        const event = calendar.getEventById(eventId);
                        if (event) event.remove();

                        bootstrap.Modal
                            .getInstance(document.getElementById("eventModal"))
                            .hide();
                    });
            });
        });
    });
});
</script>

{% endblock %}